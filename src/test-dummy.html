<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>COBE Globe â€” dropdown, idle rotate, drag</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        --max-width: 720px;
      }
      /* body {
        margin: 0;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
        display: flex;
        min-height: 100vh;
        align-items: center;
        justify-content: center;
        background: #000;
        color: #111;
      } */
      .map-view .card {
        width: 100%;
        max-width: var(--max-width);
        margin: 1rem;
      }
      .map-view #globeWrap {
        position: relative;
        width: 100%;
        aspect-ratio: 1;
        max-width: var(--max-width);
        margin: 0 auto;
        border-radius: 14px;
        overflow: hidden;
        /* background: white; */
        touch-action: none; /* allow pointer events for drag */
      }
      .map-view canvas {
        width: 100%;
        height: 100%;
        display: block;
        opacity: 0;
        transition: opacity 600ms ease;
        background: transparent;
        cursor: grab;
      }
      .map-view canvas:active {
        cursor: grabbing;
      }
      .map-view .controls {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        padding: 0.8rem 0;
        flex-wrap: wrap;
        user-select: none;
        background-color: #fff;
      }
      .map-view select,
      .map-view button {
        height: inherit;
        appearance: none;
        -webkit-appearance: none;
        font-size: 14px;
        padding: 6px 14px !important;
        border-radius: 45px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        background: rgba(0, 0, 0, 0.03);
        cursor: pointer;
      }
      .map-view select {
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='%23000000'%20viewBox='0%200%2030.727%2030.727'%3E%3Cpath%20d='M29.994%2C10.183L15.363%2C24.812L0.733%2C10.184c-0.977-0.978-0.977-2.561%2C0-3.536c0.977-0.977%2C2.559-0.976%2C3.536%2C0%20%20%20%20l11.095%2C11.093L26.461%2C6.647c0.977-0.976%2C2.559-0.976%2C3.535%2C0C30.971%2C7.624%2C30.971%2C9.206%2C29.994%2C10.183z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 1rem center;
        background-size: 1em;
        padding-right: 2.5em; /* Make room for the arrow */
      }
      .map-view .small {
        font-size: 13px;
        padding: 6px 8px;
      }
      .map-view .legend {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        color: #444;
        font-size: 13px;
      }
      .map-view .dot-swatch {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: black;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 420px) {
        .map-view .controls {
          gap: 0.4rem;
          padding: 0.6rem 0;
        }
        .map-view select,
        .map-view button {
          padding: 6px 8px;
          font-size: 13px;
        }
      }
      .map-view .toggle-wrapper {
        display: flex;
        align-items: center;
        border-radius: 50px;
        overflow: hidden;
        border: 4px solid black;
        width: 285px;
        font-family: sans-serif;
        background-color: #000;
      }

      .map-view input[type="radio"] {
        display: none;
      }

      .map-view .toggle-label {
        flex: 1;
        text-align: center;
        padding: 12px 0;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
      }

      /* Default styles */
      .map-view .us-label {
        background: white;
        color: black;
        border-radius: 45px;
      }

      .map-view .global-label {
        background: black;
        color: gray;
      }

      /* When "Global Map" is selected */
      .map-view #global:checked ~ .toggle-wrapper .us-label {
        background: black;
        color: gray;
      }

      .map-view #global:checked ~ .toggle-wrapper .global-label {
        background: white;
        color: black;
        border-radius: 45px;
      }

      /* When "U.S. locations" is selected */
      .map-view #us:checked ~ .toggle-wrapper .us-label {
        background: white;
        color: black;
      }

      .map-view #us:checked ~ .toggle-wrapper .global-label {
        background: black;
        color: gray;
      }
      #cobeCanvas {
        pointer-events: auto;
        position: relative;
        z-index: 1;
      }
      #tooltip {
        z-index: 2;
      }

      #tooltip a {
        color: #4dbfff;
        text-decoration: none;
      }
      #tooltip a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <section class="map-view">
      <div class="card">
        <div class="controls" style="margin-top: 0.6rem">
          <div>
            <input type="radio" name="toggle" id="us" checked />
            <input type="radio" name="toggle" id="global" />

            <!-- Toggle switch -->
            <div class="toggle-wrapper">
              <label for="us" class="toggle-label us-label"
                >U.S. locations</label
              >
              <label for="global" class="toggle-label global-label"
                >Global Map</label
              >
            </div>
          </div>
          <select id="locationSelect" class="small"></select>
          <!-- <button id="fitButton" class="small">Fit / Center</button> -->

          <!-- <div class="legend" style="margin-left: 0.6rem">
          <div class="dot-swatch" aria-hidden="true"></div>
          <div>Marker</div>
        </div> -->
        </div>
        <div
          id="tooltip"
          style="
            position: absolute;
            padding: 12px 14px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            font-size: 15px;
            border-radius: 6px;
            pointer-events: auto; /* ðŸ‘ˆ enables click inside tooltip */
            z-index: 9999; /* ðŸ‘ˆ stays above canvas */
            left: 384px;
            display: none;
            top: 50%;
            right: 0;
            width: 320px;
            line-height: 1.4;
          "
        ></div>
        <div id="globeWrap">
          <canvas id="cobeCanvas"></canvas>
        </div>
      </div>
    </section>
    <script type="module">
      // import createGlobe from "https://cdn.skypack.dev/cobe"; // original
      import createGlobe from "https://esm.sh/cobe@0.6.3"; // more reliable CDN

      // ---- Config ----
      const LOCATIONS = [
        {
          name: "Custom Software Development â€” New Jersey",
          lat: 40.7128,
          lon: -74.006,
          size: 0.11,
        },
        {
          name: "Software Development â€” Mumbai",
          lat: 19.076,
          lon: 72.8777,
          size: 0.1,
        },
        {
          name: "Development Center â€” Beijing",
          lat: 39.9042,
          lon: 116.4074,
          size: 0.09,
        },
        {
          name: "App Development â€” Osaka",
          lat: 34.6937,
          lon: 135.5022,
          size: 0.085,
        },
      ];

      function locationToAngles(latDeg, lonDeg) {
        // Math.PI
        return [
          Math.PI - ((lonDeg * Math.PI) / 180 - Math.PI / 2), // phi
          (latDeg * Math.PI) / 180, // theta
        ];
      }

      const canvas = document.getElementById("cobeCanvas");
      const selectEl = document.getElementById("locationSelect");
      const tooltip = document.getElementById("tooltip");
      // const fitButton = document.getElementById("fitButton");
      tooltip.style.display = "none";
      const placeholderOption = document.createElement("option");
      placeholderOption.value = "";
      placeholderOption.textContent = "Select a location";
      placeholderOption.disabled = true;
      placeholderOption.selected = true;
      selectEl.insertBefore(placeholderOption, selectEl.firstChild);

      // Populate select
      LOCATIONS.forEach((loc, idx) => {
        const opt = document.createElement("option");
        opt.value = idx;
        opt.textContent = loc.name;
        selectEl.appendChild(opt);
      });

      // State
      let widthCss = 0;
      let widthPx = 0;
      let currentPhi = 0;
      let currentTheta = 0.3;
      let focusPhi = 0;
      let focusTheta = 0;
      let lastInteractionTime = Date.now();
      const idleRotationSpeed = 0.0008; // radians per frame-ish (unused but kept)

      // Dragging state (pointer)
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartPhi = 0;
      let dragStartTheta = 0;

      // marker blink state
      let activeMarkerIndex = 0; // default: first marker
      let blinkStartTime = Date.now();
      const BLINK_SPEED_HZ = 2.2;
      const BLINK_AMPLITUDE = 0.85;

      // guard so Global change handler doesn't clear selection when set programmatically
      let suppressGlobalHandler = false;

      // Set default focus to first location
      selectEl.selectedIndex = 0;
      [focusPhi, focusTheta] = locationToAngles(
        LOCATIONS[0].lat,
        LOCATIONS[0].lon
      );

      // Responsive sizing helper
      function recomputeSizes() {
        widthCss = canvas.offsetWidth;
        widthPx = Math.max(2, Math.floor(widthCss * 2)); // match DPR used by globe (devicePixelRatio:2)
      }
      window.addEventListener("resize", recomputeSizes);
      recomputeSizes();

      // Pointer (mouse/touch) handlers for drag rotation
      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture(e.pointerId);
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartPhi = currentPhi;
        dragStartTheta = currentTheta;
        lastInteractionTime = Date.now();
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        // convert deltas to angle offsets; sensitivity tuned for comfortable dragging
        const deltaPhi = (dx / Math.max(200, widthCss)) * Math.PI * 2; // full width â‰ˆ 2Ï€
        const deltaTheta = (dy / Math.max(200, widthCss)) * Math.PI; // vertical movement maps to +/- Ï€/2
        // update current angles directly while dragging
        currentPhi = dragStartPhi + deltaPhi;
        currentTheta = clamp(
          dragStartTheta + deltaTheta,
          -Math.PI / 2 + 0.01,
          Math.PI / 2 - 0.01
        );
        lastInteractionTime = Date.now();
      });

      function endDrag(e) {
        if (isDragging) {
          isDragging = false;
          try {
            canvas.releasePointerCapture(e.pointerId);
          } catch {}
          // After drag, snap focus to the new orientation so auto-rotation uses this base
          focusPhi = currentPhi;
          focusTheta = currentTheta;
          lastInteractionTime = Date.now();
        }
      }
      canvas.addEventListener("pointerup", endDrag);
      canvas.addEventListener("pointercancel", endDrag);

      // Utility clamp
      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      // Create globe with your look, now with BLUE markers + blink
      const globe = createGlobe(canvas, {
        devicePixelRatio: 2,
        width: widthPx || 600,
        height: widthPx || 600,
        phi: currentPhi,
        theta: currentTheta,
        dark: 0, // dark mode off
        diffuse: 3,
        mapSamples: 16000,
        mapBrightness: 1.15,
        baseColor: [1, 1, 1], // white globe
        markerColor: [0.18, 0.52, 1], // BLUE markers  <-- CHANGED
        glowColor: [1, 1, 1],
        markers: LOCATIONS.map((l) => ({
          location: [l.lat, l.lon],
          size: l.size,
        })),
        onRender: (state) => {
          recomputeSizes();
          state.width = widthPx;
          state.height = widthPx;

          if (!isDragging) {
            let intendedFocusPhi = focusPhi;

            // Smooth approach to focus without idle rotation
            const doublePi = Math.PI * 2;
            const distPositive =
              (intendedFocusPhi - currentPhi + doublePi) % doublePi;
            const distNegative =
              (currentPhi - intendedFocusPhi + doublePi) % doublePi;

            if (distPositive < distNegative) {
              currentPhi += distPositive * 0.08;
            } else {
              currentPhi -= distNegative * 0.08;
            }

            currentTheta = currentTheta * 0.92 + focusTheta * 0.08;
          }

          // --- Rebuild markers each frame so selected one can "blink" ---
          const t = (Date.now() - blinkStartTime) / 1000;
          state.markers = LOCATIONS.map((l, i) => {
            const isActive =
              i === activeMarkerIndex && activeMarkerIndex !== null;
            const pulse = isActive
              ? 1 +
                BLINK_AMPLITUDE *
                  Math.abs(Math.sin(t * Math.PI * BLINK_SPEED_HZ))
              : 1;
            const base = isActive ? l.size * 1.1 : l.size; // +10% base visibility
            return { location: [l.lat, l.lon], size: base * pulse };
          });

          state.phi = currentPhi;
          state.theta = currentTheta;
        },
      });

      // Fade in canvas
      setTimeout(() => (canvas.style.opacity = "1"), 10);

      // Dropdown & fit button
      selectEl.addEventListener("change", (e) => {
        const idx = Number(e.target.value);
        if (isNaN(idx)) return; // Don't proceed if placeholder is selected
        const selectedLocation = LOCATIONS[idx];
        const angs = locationToAngles(LOCATIONS[idx].lat, LOCATIONS[idx].lon);
        focusPhi = angs[0];
        focusTheta = angs[1];
        lastInteractionTime = Date.now();

        // programmatically flip to Global, but don't run its change logic
        suppressGlobalHandler = true;
        document.getElementById("global").checked = true;
        suppressGlobalHandler = false;

        // set active blinking marker
        activeMarkerIndex = idx;
        blinkStartTime = Date.now();

        // Tooltip preserved
        tooltip.innerHTML = `
  <div style="display:flex;align-items:center;gap:8px; align-items:center; justify-content:space-between">
    <span>${selectedLocation.name}</span>
    <a href="https://newagesysit.com/" target="_blank"
     style="text-decoration:none;display:flex;align-items:center;gap:4px;">
     <svg width="20" height="12" viewBox="0 0 10 9" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.56265 8.46826L8.4799 2.43411L8.3534 6.91126C8.34669 7.14861 8.53259 7.36171 8.76865 7.38729C8.88668 7.40023 8.99489 7.36363 9.07447 7.29422C9.15404 7.2248 9.20499 7.12256 9.20819 7.00387L9.364 1.48918C9.37071 1.25183 9.18482 1.03873 8.94875 1.01315L3.46411 0.41882C3.2282 0.393111 3.03113 0.565027 3.02457 0.802242C3.01787 1.03959 3.20376 1.25269 3.43983 1.27827L7.89271 1.76067L0.9753 7.79496C0.803713 7.94464 0.796019 8.21694 0.958127 8.40277C1.12023 8.5886 1.3909 8.61808 1.56265 8.46826Z" fill="white"/>
</svg>

  </a>
  </div>
  
`;
        tooltip.style.display = "block";

        // Position near top center of canvas
        const rect = canvas.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width / 2}px`;
        tooltip.style.top = `${rect.top + rect.height / 2}px`;
      });

      // Radio toggle behavior
      document.getElementById("us").addEventListener("change", (e) => {
        if (e.target.checked) {
          // Focus on U.S. (New Jersey)
          const usLocation = LOCATIONS[0]; // Assuming first in array is New Jersey
          const [phi, theta] = locationToAngles(usLocation.lat, usLocation.lon);
          focusPhi = phi;
          focusTheta = theta;
          lastInteractionTime = Date.now();

          // Optional: update dropdown to match (keep placeholder)
          selectEl.selectedIndex = 0;
          selectEl.value = "";
          tooltip.style.display = "none";

          // Blink NJ
          activeMarkerIndex = 0;
          blinkStartTime = Date.now();
        }
      });

      document.getElementById("global").addEventListener("change", (e) => {
        if (!e.target.checked) return;
        if (suppressGlobalHandler) return; // ignore programmatic switch

        // Keep current orientation
        focusPhi = currentPhi;
        focusTheta = currentTheta;
        lastInteractionTime = Date.now();

        // Clear dropdown selection ONLY; keep current blinking marker
        selectEl.selectedIndex = 0;
        selectEl.value = "";
        tooltip.style.display = "none";
        // NOTE: we do NOT clear activeMarkerIndex here
      });

      // Cleanup on unload
      window.addEventListener("beforeunload", () => {
        try {
          globe.destroy();
        } catch (e) {}
      });

      // Ensure focusPhi/focusTheta start from the selected location
      (function initFocusFromSelect() {
        const [phi, theta] = locationToAngles(
          LOCATIONS[0].lat,
          LOCATIONS[0].lon
        );
        focusPhi = phi;
        focusTheta = theta;
        currentPhi = phi;
        currentTheta = theta;
        activeMarkerIndex = 0;
        blinkStartTime = Date.now();
      })();
    </script>
  </body>
</html>
