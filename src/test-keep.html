<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>COBE Globe — dropdown, idle rotate, drag</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        --max-width: 720px;
      }
      /* body {
        margin: 0;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
        display: flex;
        min-height: 100vh;
        align-items: center;
        justify-content: center;
        background: #000;
        color: #111;
      } */
      .map-view .card {
        width: 100%;
        max-width: var(--max-width);
        margin: 1rem;
      }
      .map-view #globeWrap {
        position: relative;
        width: 100%;
        aspect-ratio: 1;
        max-width: var(--max-width);
        margin: 0 auto;
        border-radius: 14px;
        overflow: hidden;
        /* background: white; */
        touch-action: none; /* allow pointer events for drag */
      }
      .map-view canvas {
        width: 100%;
        height: 100%;
        display: block;
        opacity: 0;
        transition: opacity 600ms ease;
        background: transparent;
        cursor: grab;
      }
      .map-view canvas:active {
        cursor: grabbing;
      }
      .map-view .controls {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        padding: 0.8rem 0;
        flex-wrap: wrap;
        user-select: none;
        background-color: #fff;
      }
      .map-view select,
      .map-view button {
        height: inherit;
        appearance: none;
        -webkit-appearance: none;
        font-size: 14px;
        padding: 6px 14px !important;
        border-radius: 45px;
        border: 1px solid rgba(0, 0, 0, 0.08);
        background: rgba(0, 0, 0, 0.03);
        cursor: pointer;
      }
      .map-view select {
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='%23000000'%20viewBox='0%200%2030.727%2030.727'%3E%3Cpath%20d='M29.994%2C10.183L15.363%2C24.812L0.733%2C10.184c-0.977-0.978-0.977-2.561%2C0-3.536c0.977-0.977%2C2.559-0.976%2C3.536%2C0%20%20%20%20l11.095%2C11.093L26.461%2C6.647c0.977-0.976%2C2.559-0.976%2C3.535%2C0C30.971%2C7.624%2C30.971%2C9.206%2C29.994%2C10.183z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 1rem center;
        background-size: 1em;
        padding-right: 2.5em; /* Make room for the arrow */
      }
      .map-view .small {
        font-size: 13px;
        padding: 6px 8px;
      }
      .map-view .legend {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        color: #444;
        font-size: 13px;
      }
      .map-view .dot-swatch {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: black;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 420px) {
        .map-view .controls {
          gap: 0.4rem;
          padding: 0.6rem 0;
        }
        .map-view select,
        .map-view button {
          padding: 6px 8px;
          font-size: 13px;
        }
      }
      .map-view .toggle-wrapper {
        display: flex;
        align-items: center;
        border-radius: 50px;
        overflow: hidden;
        border: 4px solid black;
        width: 285px;
        font-family: sans-serif;
        background-color: #000;
      }

      .map-view input[type="radio"] {
        display: none;
      }

      .map-view .toggle-label {
        flex: 1;
        text-align: center;
        padding: 12px 0;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
      }

      /* Default styles */
      .map-view .us-label {
        background: white;
        color: black;
        border-radius: 45px;
      }

      .map-view .global-label {
        background: black;
        color: gray;
      }

      /* When "Global Map" is selected */
      .map-view #global:checked ~ .toggle-wrapper .us-label {
        background: black;
        color: gray;
      }

      .map-view #global:checked ~ .toggle-wrapper .global-label {
        background: white;
        color: black;
        border-radius: 45px;
      }

      /* When "U.S. locations" is selected */
      .map-view #us:checked ~ .toggle-wrapper .us-label {
        background: white;
        color: black;
      }

      .map-view #us:checked ~ .toggle-wrapper .global-label {
        background: black;
        color: gray;
      }
    </style>
  </head>
  <body>
    <section class="map-view">
      <div class="card">
        <div class="controls" style="margin-top: 0.6rem">
          <div>
            <input type="radio" name="toggle" id="us" checked />
            <input type="radio" name="toggle" id="global" />

            <!-- Toggle switch -->
            <div class="toggle-wrapper">
              <label for="us" class="toggle-label us-label"
                >U.S. locations</label
              >
              <label for="global" class="toggle-label global-label"
                >Global Map</label
              >
            </div>
          </div>
          <select id="locationSelect" class="small"></select>
          <!-- <button id="fitButton" class="small">Fit / Center</button> -->

          <!-- <div class="legend" style="margin-left: 0.6rem">
          <div class="dot-swatch" aria-hidden="true"></div>
          <div>Marker</div>
        </div> -->
        </div>
        <div
          id="tooltip"
          style="
            position: absolute;
            padding: 12px 14px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            font-size: 16px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 999;
            left: 384px;
            display: inline-block;
            top: 50% !important;
            right: 0;
            width: 300px;
          "
        ></div>
        <div id="globeWrap">
          <canvas id="cobeCanvas"></canvas>
        </div>
      </div>
    </section>
    <script type="module">
      import createGlobe from "https://cdn.skypack.dev/cobe";

      // ---- Config ----
      const LOCATIONS = [
        {
          name: "Custom Software Development — New Jersey",
          lat: 40.7128,
          lon: -74.006,
          size: 0.11,
        },
        {
          name: "Software Development — Mumbai",
          lat: 19.076,
          lon: 72.8777,
          size: 0.1,
        },
        {
          name: "Development Center — Beijing",
          lat: 39.9042,
          lon: 116.4074,
          size: 0.09,
        },
        {
          name: "App Development — Osaka",
          lat: 34.6937,
          lon: 135.5022,
          size: 0.085,
        },
      ];

      function locationToAngles(latDeg, lonDeg) {
        // Math.PI
        return [
          Math.PI - ((lonDeg * Math.PI) / 180 - Math.PI / 2), // phi
          (latDeg * Math.PI) / 180, // theta
        ];
      }

      const canvas = document.getElementById("cobeCanvas");
      const selectEl = document.getElementById("locationSelect");
      const tooltip = document.getElementById("tooltip");
      // const fitButton = document.getElementById("fitButton");
      tooltip.style.display = "none";
      const placeholderOption = document.createElement("option");
      placeholderOption.value = "";
      placeholderOption.textContent = "Select a location";
      placeholderOption.disabled = true;
      placeholderOption.selected = true;
      selectEl.insertBefore(placeholderOption, selectEl.firstChild);

      // Populate select
      LOCATIONS.forEach((loc, idx) => {
        const opt = document.createElement("option");
        opt.value = idx;
        opt.textContent = loc.name;
        selectEl.appendChild(opt);
      });

      // State
      let widthCss = 0;
      let widthPx = 0;
      let currentPhi = 0;
      let currentTheta = 0.3;
      let focusPhi = 0;
      let focusTheta = 0;
      let lastInteractionTime = Date.now();
      const idleRotationSpeed = 0.0008; // radians per frame-ish

      // Dragging state (pointer)
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartPhi = 0;
      let dragStartTheta = 0;

      // Set default focus to first location
      selectEl.selectedIndex = 0;
      [focusPhi, focusTheta] = locationToAngles(
        LOCATIONS[0].lat,
        LOCATIONS[0].lon
      );

      // Responsive sizing helper
      function recomputeSizes() {
        widthCss = canvas.offsetWidth;
        widthPx = Math.max(2, Math.floor(widthCss * 2)); // match DPR used by globe (devicePixelRatio:2)
      }
      window.addEventListener("resize", recomputeSizes);
      recomputeSizes();

      // Pointer (mouse/touch) handlers for drag rotation
      canvas.addEventListener("pointerdown", (e) => {
        canvas.setPointerCapture(e.pointerId);
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartPhi = currentPhi;
        dragStartTheta = currentTheta;
        lastInteractionTime = Date.now();
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        // convert deltas to angle offsets; sensitivity tuned for comfortable dragging
        const deltaPhi = (dx / Math.max(200, widthCss)) * Math.PI * 2; // full width ≈ 2π
        const deltaTheta = (dy / Math.max(200, widthCss)) * Math.PI; // vertical movement maps to +/- π/2
        // update current angles directly while dragging
        currentPhi = dragStartPhi + deltaPhi;
        currentTheta = clamp(
          dragStartTheta + deltaTheta,
          -Math.PI / 2 + 0.01,
          Math.PI / 2 - 0.01
        );
        lastInteractionTime = Date.now();
      });

      canvas.addEventListener("pointerup", (e) => {
        if (isDragging) {
          isDragging = false;
          try {
            canvas.releasePointerCapture(e.pointerId);
          } catch {}
          // After drag, snap focus to the new orientation so auto-rotation uses this base
          focusPhi = currentPhi;
          focusTheta = currentTheta;
          lastInteractionTime = Date.now();
        }
      });

      canvas.addEventListener("pointercancel", (e) => {
        isDragging = false;
        try {
          canvas.releasePointerCapture(e.pointerId);
        } catch {}
        focusPhi = currentPhi;
        focusTheta = currentTheta;
        lastInteractionTime = Date.now();
      });

      // Utility clamp
      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      // Create globe with dark mode off (dark: 0) and white surface, black markers
      const globe = createGlobe(canvas, {
        devicePixelRatio: 2,
        width: widthPx || 600,
        height: widthPx || 600,
        phi: currentPhi,
        theta: currentTheta,
        dark: 0, // <<-- dark mode off
        diffuse: 3,
        mapSamples: 16000,
        mapBrightness: 1.15,
        baseColor: [1, 1, 1], // white globe
        markerColor: [0, 0, 0], // black dots
        glowColor: [1, 1, 1],
        markers: LOCATIONS.map((l) => ({
          location: [l.lat, l.lon],
          size: l.size,
        })),
        onRender: (state) => {
          recomputeSizes();
          state.width = widthPx;
          state.height = widthPx;

          if (!isDragging) {
            let intendedFocusPhi = focusPhi;

            // Smooth approach to focus without idle rotation
            const doublePi = Math.PI * 2;
            const distPositive =
              (intendedFocusPhi - currentPhi + doublePi) % doublePi;
            const distNegative =
              (currentPhi - intendedFocusPhi + doublePi) % doublePi;

            if (distPositive < distNegative) {
              currentPhi += distPositive * 0.08;
            } else {
              currentPhi -= distNegative * 0.08;
            }

            currentTheta = currentTheta * 0.92 + focusTheta * 0.08;
          }

          state.phi = currentPhi;
          state.theta = currentTheta;
        },
      });

      // Fade in canvas
      setTimeout(() => (canvas.style.opacity = "1"), 10);

      // Dropdown & fit button
      selectEl.addEventListener("change", (e) => {
        const idx = Number(e.target.value);
        if (isNaN(idx)) return; // Don't proceed if placeholder is selected
        const selectedLocation = LOCATIONS[idx];
        console.log("Selected Marker:", selectedLocation);
        const angs = locationToAngles(LOCATIONS[idx].lat, LOCATIONS[idx].lon);
        focusPhi = angs[0];
        focusTheta = angs[1];
        lastInteractionTime = Date.now();

        document.getElementById("global").checked = true;

        tooltip.textContent = selectedLocation.name;
        tooltip.style.display = "block";

        // Position near top center of canvas
        const rect = canvas.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width / 2}px`;
        tooltip.style.top = `${rect.top + rect.height / 2}px`;
      });
      // fitButton.addEventListener("click", () => {
      //   const idx = Number(selectEl.value || 0);
      //   const angs = locationToAngles(LOCATIONS[idx].lat, LOCATIONS[idx].lon);
      //   focusPhi = angs[0];
      //   focusTheta = angs[1];
      //   lastInteractionTime = Date.now();
      // });
      // Radio toggle behavior
      document.getElementById("us").addEventListener("change", (e) => {
        if (e.target.checked) {
          // Focus on U.S. (New Jersey)
          const usLocation = LOCATIONS[0]; // Assuming first in array is New Jersey
          const [phi, theta] = locationToAngles(usLocation.lat, usLocation.lon);
          focusPhi = phi;
          focusTheta = theta;
          lastInteractionTime = Date.now();

          // Optional: update dropdown to match
          selectEl.selectedIndex = 0;
          selectEl.value = "";
          tooltip.style.display = "none";
        }
      });

      document.getElementById("global").addEventListener("change", (e) => {
        if (e.target.checked) {
          // Reset to idle rotation starting from current orientation
          focusPhi = currentPhi;
          focusTheta = currentTheta;
          lastInteractionTime = Date.now();

          // Optional: Clear dropdown selection
          selectEl.selectedIndex = 0;
          selectEl.value = "";
          tooltip.style.display = "none";
        }
      });

      // Cleanup on unload
      window.addEventListener("beforeunload", () => {
        try {
          globe.destroy();
        } catch (e) {}
      });

      // Ensure focusPhi/focusTheta start from the selected location
      (function initFocusFromSelect() {
        const idx = Number(selectEl.value || 0);
        const angs = locationToAngles(LOCATIONS[idx].lat, LOCATIONS[idx].lon);
        focusPhi = angs[0];
        focusTheta = angs[1];
        currentPhi = focusPhi;
        currentTheta = focusTheta;
      })();
    </script>
  </body>
</html>
