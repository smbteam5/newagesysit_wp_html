<!-- just old -->
<script type="module">
  import createGlobe from "https://esm.sh/cobe@0.6.3";

  // ---- Config (unchanged) ----
  const LOCATIONS = [
    // Existing
    {
      name: "Custom Software Development — New Jersey",
      lat: 40.7128,
      lon: -74.006,
      size: 0.11,
    },
    {
      name: "App Development in Jacksonville",
      lat: 30.3322,
      lon: -81.6557,
      size: 0.085,
    },
    {
      name: "App Development in Philadelphia",
      lat: 39.9526,
      lon: -75.1652,
      size: 0.085,
    },
    {
      name: "App Development in Tampa",
      lat: 27.9506,
      lon: -82.4572,
      size: 0.085,
    },
    {
      name: "App Development in Miami",
      lat: 25.7617,
      lon: -80.1918,
      size: 0.085,
    },
    {
      name: "App Development in Atlanta",
      lat: 33.749,
      lon: -84.388,
      size: 0.085,
    },
    {
      name: "App Development in Charlotte",
      lat: 35.2271,
      lon: -80.8431,
      size: 0.085,
    },
    {
      name: "App Development in New York",
      lat: 40.7128,
      lon: -74.006,
      size: 0.085,
    },

    {
      name: "Mobile App Development in Virginia",
      lat: 37.5407,
      lon: -77.436,
      size: 0.082,
    }, // Richmond
    {
      name: "Mobile App Development in Georgia",
      lat: 33.749,
      lon: -84.388,
      size: 0.082,
    }, // Atlanta
    {
      name: "Mobile App Development in Pennsylvania",
      lat: 40.2732,
      lon: -76.8867,
      size: 0.082,
    }, // Harrisburg

    {
      name: "Staff Augmentation in California",
      lat: 34.0522,
      lon: -118.2437,
      size: 0.082,
    }, // Los Angeles
    {
      name: "App Development in Philly",
      lat: 39.9526,
      lon: -75.1652,
      size: 0.081,
    }, // Same as Philadelphia
    {
      name: "Staff Augmentation in Texas",
      lat: 30.2672,
      lon: -97.7431,
      size: 0.082,
    }, // Austin
    {
      name: "Staff Augmentation in New York",
      lat: 40.7128,
      lon: -74.006,
      size: 0.082,
    },

    // International
    {
      name: "Staff Augmentation in South Africa",
      lat: -26.2041,
      lon: 28.0473,
      size: 0.083,
    }, // Johannesburg
  ];

  function locationToAngles(latDeg, lonDeg) {
    return [
      Math.PI - ((lonDeg * Math.PI) / 180 - Math.PI / 2), // phi
      (latDeg * Math.PI) / 180, // theta
    ];
  }
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  const canvas = document.getElementById("cobeCanvas");
  const selectEl = document.getElementById("locationSelect");
  const tooltip = document.getElementById("tooltip");

  // Populate select (unchanged)
  tooltip.style.display = "none";
  const placeholderOption = document.createElement("option");
  placeholderOption.value = "";
  placeholderOption.textContent = "Select a location";
  placeholderOption.disabled = true;
  placeholderOption.selected = true;
  selectEl.insertBefore(placeholderOption, selectEl.firstChild);
  LOCATIONS.forEach((loc, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = loc.name;
    selectEl.appendChild(opt);
  });

  // ---- State (unchanged core) ----
  let currentPhi = 0;
  let currentTheta = 0.3;
  let focusPhi = 0;
  let focusTheta = 0;

  let isDragging = false;
  let dragStartX = 0,
    dragStartY = 0,
    dragStartPhi = 0,
    dragStartTheta = 0;

  let activeMarkerIndex = 0;
  let blinkStartTime = Date.now();
  const BLINK_SPEED_HZ = 2.2;
  const BLINK_AMPLITUDE = 0.85;

  let suppressGlobalHandler = false;

  // ---- Sizing & robustness ----
  let dpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
  let widthCss = 0;
  let widthPx = 0;
  let sizeDirty = true;
  let lastNonZeroCss = 600; // fallback to avoid 0×0 canvas

  function recomputeSizes() {
    // Prefer parent size; fall back to canvas; never allow 0
    const parent = canvas.parentElement;
    const cssW = Math.max(
      parent ? parent.clientWidth : 0,
      canvas.clientWidth || 0,
      0
    );
    widthCss = cssW > 20 ? cssW : lastNonZeroCss;
    lastNonZeroCss = widthCss;

    widthPx = Math.max(2, Math.floor(widthCss * dpr));
    sizeDirty = true;
  }

  // Initial sizing
  recomputeSizes();

  // Keep an eye on actual layout changes (more reliable than window.resize alone)
  const ro = new ResizeObserver(() => {
    const newDpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    if (newDpr !== dpr) dpr = newDpr;
    recomputeSizes();
  });
  try {
    ro.observe(canvas.parentElement || canvas);
  } catch {}

  // Also listen to window resize (covers zoom / viewport changes)
  let rzTimer;
  window.addEventListener("resize", () => {
    clearTimeout(rzTimer);
    rzTimer = setTimeout(() => {
      const newDpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
      if (newDpr !== dpr) dpr = newDpr;
      recomputeSizes();
    }, 120);
  });

  // Refresh when tab becomes visible again
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      const newDpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
      if (newDpr !== dpr) dpr = newDpr;
      recomputeSizes();
      // nudge the blink so markers re-pulse immediately
      blinkStartTime = Date.now();
    }
  });

  // ---- Pointer controls (unchanged) ----
  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartPhi = currentPhi;
    dragStartTheta = currentTheta;
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const denom = Math.max(200, widthCss || 600);
    const deltaPhi = (dx / denom) * Math.PI * 2;
    const deltaTheta = (dy / denom) * Math.PI;
    currentPhi = dragStartPhi + deltaPhi;
    currentTheta = clamp(
      dragStartTheta + deltaTheta,
      -Math.PI / 2 + 0.01,
      Math.PI / 2 - 0.01
    );
  });
  function endDrag(e) {
    if (!isDragging) return;
    isDragging = false;
    try {
      canvas.releasePointerCapture(e.pointerId);
    } catch {}
    focusPhi = currentPhi;
    focusTheta = currentTheta;
  }
  canvas.addEventListener("pointerup", endDrag);
  canvas.addEventListener("pointercancel", endDrag);

  // ---- Globe lifecycle (allows re-init on WebGL restore) ----
  let globe = null;
  function buildGlobe() {
    if (globe) {
      try {
        globe.destroy();
      } catch {}
      globe = null;
    }

    globe = createGlobe(canvas, {
      devicePixelRatio: dpr,
      width: widthPx || 600,
      height: widthPx || 600,
      phi: currentPhi,
      theta: currentTheta,
      dark: 0,
      diffuse: 2.5,
      mapSamples: 5000, // lighter, fast
      mapBrightness: 1.15,
      baseColor: [1, 1, 1],
      markerColor: [0.18, 0.52, 1],
      glowColor: [1, 1, 1],
      markers: LOCATIONS.map((l) => ({
        location: [l.lat, l.lon],
        size: l.size,
      })),
      onRender: (state) => {
        // apply pending size changes once
        if (sizeDirty) {
          state.devicePixelRatio = dpr;
          state.width = widthPx;
          state.height = widthPx;
          sizeDirty = false;
        }

        // Smooth focus (no idle autorotation)
        if (!isDragging) {
          const TWO_PI = Math.PI * 2;
          const dp = (focusPhi - currentPhi + TWO_PI) % TWO_PI;
          const dn = (currentPhi - focusPhi + TWO_PI) % TWO_PI;
          currentPhi += (dp < dn ? dp : -dn) * 0.08;
          currentTheta = currentTheta * 0.92 + focusTheta * 0.08;
        }

        // Blink active marker
        const t = (Date.now() - blinkStartTime) / 1000;
        state.markers = LOCATIONS.map((l, i) => {
          const active = i === activeMarkerIndex && activeMarkerIndex != null;
          const pulse = active
            ? 1 +
              BLINK_AMPLITUDE * Math.abs(Math.sin(t * Math.PI * BLINK_SPEED_HZ))
            : 1;
          const base = active ? l.size * 1.1 : l.size;
          return { location: [l.lat, l.lon], size: base * pulse };
        });

        state.phi = currentPhi;
        state.theta = currentTheta;
      },
    });
  }

  // Default focus
  [focusPhi, focusTheta] = locationToAngles(LOCATIONS[0].lat, LOCATIONS[0].lon);
  currentPhi = focusPhi;
  currentTheta = focusTheta;
  activeMarkerIndex = null;
  blinkStartTime = Date.now();

  // Build the globe
  buildGlobe();

  // Fade in
  setTimeout(() => (canvas.style.opacity = "1"), 20);

  // ---- WebGL context loss / restore handling ----
  // Some browsers will drop WebGL contexts under memory pressure or after inactivity.
  canvas.addEventListener(
    "webglcontextlost",
    (e) => {
      // Prevent default so we can restore ourselves.
      e.preventDefault();
      // No need to do anything else here; wait for restore event.
      // Optionally, you could show a subtle "reloading" state.
    },
    { passive: false }
  );

  canvas.addEventListener("webglcontextrestored", () => {
    // Recompute sizes & DPR (in case environment changed)
    const newDpr = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    if (newDpr !== dpr) dpr = newDpr;
    recomputeSizes();
    // Rebuild with the *current* state (phi/theta/markers preserved)
    buildGlobe();
  });

  // ---- Controls (unchanged behavior) ----
  selectEl.addEventListener("change", (e) => {
    const idx = Number(e.target.value);
    if (isNaN(idx)) return;
    const selectedLocation = LOCATIONS[idx];
    const [phi, theta] = locationToAngles(
      selectedLocation.lat,
      selectedLocation.lon
    );
    focusPhi = phi;
    focusTheta = theta;

    suppressGlobalHandler = true;
    document.getElementById("global").checked = true;
    suppressGlobalHandler = false;

    activeMarkerIndex = idx;
    blinkStartTime = Date.now();

    tooltip.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
        <span>${selectedLocation.name}</span>
        <a href="https://newagesysit.com/" target="_blank"
           style="text-decoration:none;display:flex;align-items:center;gap:4px;">
          <svg width="20" height="12" viewBox="0 0 10 9" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M1.56265 8.46826L8.4799 2.43411L8.3534 6.91126C8.34669 7.14861 8.53259 7.36171 8.76865 7.38729C8.88668 7.40023 8.99489 7.36363 9.07447 7.29422C9.15404 7.2248 9.20499 7.12256 9.20819 7.00387L9.364 1.48918C9.37071 1.25183 9.18482 1.03873 8.94875 1.01315L3.46411 0.41882C3.2282 0.393111 3.03113 0.565027 3.02457 0.802242C3.01787 1.03959 3.20376 1.25269 3.43983 1.27827L7.89271 1.76067L0.9753 7.79496C0.803713 7.94464 0.796019 8.21694 0.958127 8.40277C1.12023 8.5886 1.3909 8.61808 1.56265 8.46826Z" fill="white"/>
          </svg>
        </a>
      </div>`;
    tooltip.style.display = "block";
  });

  document.getElementById("us").addEventListener("change", (e) => {
    if (e.target.checked) {
      const usLocation = LOCATIONS[0];
      const [phi, theta] = locationToAngles(usLocation.lat, usLocation.lon);
      focusPhi = phi;
      focusTheta = theta;

      selectEl.selectedIndex = 0;
      selectEl.value = "";
      tooltip.style.display = "none";

      activeMarkerIndex = null;
      // blinkStartTime = Date.now();
    }
  });

  document.getElementById("global").addEventListener("change", (e) => {
    if (!e.target.checked) return;
    if (suppressGlobalHandler) return;

    // Keep current orientation; clear dropdown only
    focusPhi = currentPhi;
    focusTheta = currentTheta;
    selectEl.selectedIndex = 0;
    selectEl.value = "";
    tooltip.style.display = "none";
  });

  // Cleanup on unload
  window.addEventListener("beforeunload", () => {
    try {
      ro.disconnect();
    } catch {}
    try {
      globe?.destroy();
    } catch {}
  });
</script>
